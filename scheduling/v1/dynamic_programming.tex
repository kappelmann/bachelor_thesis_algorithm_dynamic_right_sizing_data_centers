\documentclass[hidelinks]{article}

%% Deutsche Silbentrennung und Sprache (neue Rechtschreibung)
\usepackage[english]{babel}
%% Verwende Umlaute direkt
\usepackage[utf8x]{inputenc}
%% Hyperlinks für interne Referenzen
\usepackage{hyperref}
%% Grafiken einbinden
\usepackage{graphicx}
\usepackage{float}
%% Paket für Unterabbildungen pro Abbildung
\usepackage{subfig}

\usepackage{forloop}

\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\newcommand*\Let[2]{\State #1 $\gets$ #2}
\algrenewcomment[1]{\(\qquad \triangleright\) #1}

\usepackage{mathtools}
% Proof system
\usepackage{amsthm}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{bsp}[thm]{Example}

\newtheoremstyle{rem} % name
    {\topsep}                    % Space above
    {\topsep}                    % Space below
    {}                   % Body font
    {}                           % Indent amount
    {\bf}                   % Theorem head font
    {:}                          % Punctuation after theorem head
    {.5em}                       % Space after theorem head
    {}  % Theorem head spec (can be left empty, meaning ‘normal’)

\theoremstyle{rem}
\newtheorem*{remark}{Note}

%\usepackage{xpatch}
%\makeatletter
%% Remove last point from definitions, theorems, etc.
%\xpatchcmd{\@thm}{\thm@headpunct{.}}{\thm@headpunct{\\}}{}{}
%\makeatother

% Seitenränder
\usepackage[margin=1.5in]{geometry}
% Zitate
\usepackage{cite}
% Tabellen
\usepackage[table]{xcolor}

% Graphs
\usepackage{tikz}
\usepackage{tikz-3dplot}
\usepackage{pgfplots}

\setlength{\parindent}{0pt}

% Titel der Arbeit
\title{Power management - Dynamic Programming}
% Angaben zum Author
\author{Kevin Kappelmann\\
  \multicolumn{1}{p{.7\textwidth}}{\centering\emph{Chair for Theoretical Computer Science,\\
  Technical University of Munich}}}  

\pagestyle{plain}

%------------------------------------------------------------------------------
\begin{document}

\pagenumbering{arabic}

\begin{sloppypar}

\begin{algorithm}[H]
    \caption{Optimal schedule for $m=2$ homogeneous servers}
    \begin{algorithmic}[1]
        \Require{Convex cost function $f$, $\lambda_0=\lambda_T=0$, $\forall t\in[T-1]:\lambda_t\in(0,2]$}
   \Function{schedule}{$T,\beta,\lambda_1,\ldots,\lambda_{T-1}$}
	\If{$T<2$}
		\Return{$(0,0)$}
	\EndIf

	\Let{$m_{1,1}.prev$}{$m_{1,2}.prev\leftarrow0$}
	\Let{$m_{1,1}.costs$}{$\Call{costs}{\lambda_1,1}+\beta$} \Comment{Costs using 1 server at $t=1$}
	\Let{$m_{1,2}.costs$}{$\Call{costs}{\lambda_1,2}+2*\beta$} \Comment{Costs using 2 servers at $t=1$}
	%\Let{$x_1$}{$\Call{optimal}{m_{1,1},m_{1,2}}$} \Comment{Optimal amount of active servers at $t=1$}
	\For{$t \gets 2 \textrm{ to } T-1$}
		\Let{$m_{t,1}.prev$}{$prev\leftarrow\Call{Optimal}{t-1}$} \Comment{Shortest path using 1 machine}
		\Let{$m_{t,1}.costs$}{$m_{t-1,prev}+\Call{costs}{\lambda_t,1}$}
		%\Let{$acc_1$}{$\Call{costs}{\lambda_t,1}$} \Comment{Calculate shortest path using 1 machine at t}
		%\Let{$m_{t,1}.costs$}{$m_{t-1,1}.costs+acc_1$}
		%\Let{$acc_1$}{$m_{t-1,2}.costs+acc_1$}
		%\If{$acc_1<m_{t,1}.costs$} \Comment{Decide if 1 or 2 machines at t-1 is cheaper}
			%\Let{$m_{t,1}.costs$}{$acc_1$}
			%\Let{$m_{t,1}.prev$}{$2$}
		%\Else
			%\Let{$m_{t,1}.prev$}{$1$}
		%\EndIf
		\Let{$acc$}{$\Call{costs}{\lambda_t,2}$} \Comment{Shortest path using 2 machines}
		\Let{$m_{t,2}.costs$}{$m_{t-1,2}.costs+acc$}
		\Let{$acc$}{$m_{t-1,1}.costs+\beta+acc$}
		\If{$acc<m_{t,2}.costs$}
			\Let{$m_{t,2}.costs$}{$acc$}
			\Let{$m_{t,2}.prev$}{$1$}
		\Else
			\Let{$m_{t,2}.prev$}{$2$}
		\EndIf
		%\For{$t' \gets t-2 \textrm{ to } 1$}
			%\Let{$acc_1$}{$acc_1+\Call{costs}{\lambda_{t'+1},2}$}
			%\If{$m_{t',1}+acc<m_{t,1}$}
				%\Let{$m_{t,1}$}{$m_{t',1}+acc_1$}
			%\EndIf
			%\Let{$acc_2$}{$acc_2+\Call{costs}{\lambda_{t'+1},1}$}
			%\If{$m_{t',2}+acc<m_{t,2}$}
				%\Let{$m_{t,2}$}{$m_{t',2}+acc_2$}
			%\EndIf
		%\EndFor
		%\Let{$acc_1$}{$acc_1+\Call{costs}{\lambda_{1},2}$}
		%\If{$acc_1<m_{t,1}$}
			%\Let{$m_{t,1}$}{$acc_1$}
		%\EndIf
		%\Let{$acc_2$}{$acc_2+\Call{costs}{\lambda_{1},1}$}
		%\If{$acc_2<m_{t,2}$}
			%\Let{$m_{t,2}$}{$acc_2$}
		%\EndIf
	\EndFor
	\Let{$x_0$}{$x_T\leftarrow0$} \Comment{Extract shortest path from calculations}
	\Let{$prev$}{$\Call{optimal}{T-1}$}
	\For{$t \gets T-1 \textrm{ to } 1$}
		\Let{$x_t$}{$prev$}
		\Let{$prev$}{$m_{t,prev}.prev$}
	\EndFor
	\State \Return{$(x_0,\ldots,x_T)$}
  \EndFunction
  \State
  \Function{Optimal}{$t$}
	\If{$m_{t,1}.costs<m_{t,2}.costs$}
		\State \Return{$1$}
	\EndIf
	\State \Return{$2$}
  \EndFunction
  \State
  \Function{costs}{$\lambda,x$}
	\If{$x<\lambda$}
		\State \Return{$\infty$} \Comment{Too few servers}
	\EndIf
	\State \Return{$x*f(\lambda/x)$}
  \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{proof}[Sketch for proof of correctness]
We show that the algorithm calculates the correct costs and returns an optimal schedule $\forall T\in\mathbb{N}_{\ge 2}$ using induction.
\begin{enumerate}
\item[\textbf{Basis:}] For $T=2$ it holds $\lambda_0=\lambda_2=x_0=x_T=0$ and $\lambda_1\in(0,2]$. Therefore, the costs for the optimal schedule are $min\bigl\{f(\lambda_1)+\beta, f(\lambda_1/2)+2*\beta\bigr\}$. These costs are calculated at line 4-5 and minimized at line 18.\end{enumerate}
\item[\textbf{Inductive step:}] Assuming the algorithm delivers a correct result for $T\in\mathbb{N}_{\ge 2}$, we show that it delivers a correct result for $T+1$.\\
Firstly, we recognize that the executed statements of the algorithm for $T$ and $T+1$ are the same up to the last iteration of the for-loop at line 6. Hence, using the induction hypothesis, we can assume that $m_{1,\{1,2\}}$ up to $m_{T-1,\{1,2\}}$ are calculated correctly at this point.\\
In order to calculate the minimum costs for using 1 machine at time T, we simply need to find $min\bigl\{m_{T-1,1},m_{T-1,2}\bigr\}+f(\lambda_T)$. This step is handled at line 7-8.\\
In order to calculate the minimum costs for using 2 machines at time T, we need to find $min\bigl\{m_{T-1,1}+\beta,m_{T-1,2}\bigr\}+f(\lambda_T/2)$. This step is handled at line 9-16.\\
Note: We do not need to consider possibilities where 2 servers are active but only 1 server is used. This follows from the convexity of $f$:
    \begin{alignat*}{5}
        f\Bigl(\frac{0+\lambda_t}{2}\Bigr)&=&f\Bigl(\frac{\lambda_t}{2}\Bigr)&\stackrel{convexity}{\le}\frac{f(0)+f(\lambda_t)}{2}\\
        &\Leftrightarrow\quad&\underbrace{2*f\Bigl(\frac{\lambda_t}{2}\Bigr)}_{\text{using 2 servers}}&\quad\le\underbrace{f(0)+f(\lambda_t)}_{\text{2 active servers, using only 1}}
    \end{alignat*}
\end{proof}
\end{sloppypar}
\end{document}
