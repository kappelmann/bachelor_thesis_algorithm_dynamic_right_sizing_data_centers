\documentclass[hidelinks]{article}

%% Deutsche Silbentrennung und Sprache (neue Rechtschreibung)
\usepackage[english]{babel}
%% Verwende Umlaute direkt
\usepackage[utf8x]{inputenc}
%% Hyperlinks für interne Referenzen
\usepackage{hyperref}
%% Grafiken einbinden
\usepackage{graphicx}
\usepackage{float}
%% Paket für Unterabbildungen pro Abbildung
\usepackage{subfig}

\usepackage{forloop}

\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\newcommand\Let[2]{\State #1 $\gets$ #2}
\algrenewcomment[1]{\(\qquad \triangleright\) #1}
\newcommand\Blet[2]{\State \textbf{let} #1 \textbf{be} #2}

\usepackage{mathtools}
% Proof system
\usepackage{amsthm}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{bsp}[thm]{Example}

\newtheoremstyle{rem} % name
    {\topsep}                    % Space above
    {\topsep}                    % Space below
    {}                   % Body font
    {}                           % Indent amount
    {\bf}                   % Theorem head font
    {:}                          % Punctuation after theorem head
    {.5em}                       % Space after theorem head
    {}  % Theorem head spec (can be left empty, meaning ‘normal’)

\theoremstyle{rem}
\newtheorem*{remark}{Note}

%\usepackage{xpatch}
%\makeatletter
%% Remove last point from definitions, theorems, etc.
%\xpatchcmd{\@thm}{\thm@headpunct{.}}{\thm@headpunct{\\}}{}{}
%\makeatother

% Seitenränder
%TODO originally 1.5 in
\usepackage[margin=1.3in]{geometry}
% Zitate
\usepackage{cite}
% Tabellen
\usepackage[table]{xcolor}

% Graphs
\usepackage{tikz}
\usetikzlibrary{calc,arrows.meta,positioning}
\usepackage{tikz-3dplot}
\usepackage{pgfplots}

\setlength{\parindent}{0pt}

% Titel der Arbeit
\title{Power management - Dynamic Programming}
% Angaben zum Author
\author{Kevin Kappelmann\\
  \multicolumn{1}{p{.7\textwidth}}{\centering\emph{Chair for Theoretical Computer Science,\\
  Technical University of Munich}}}  

\pagestyle{plain}

%------------------------------------------------------------------------------
\begin{document}

\pagenumbering{arabic}

\begin{sloppypar}
\section{Optimal scheduling for n homogeneous servers}
Input:
\begin{itemize}
	\item $n$: Number of homogeneous servers
	\item $T$: Number of time steps
	\item $\beta$: Power up costs
	\item $\lambda_1,\ldots,\lambda_{T-1}\in[0,n]$: Arrival rates
\end{itemize}
Requirements:
\begin{itemize}
	\item Convex cost function $f$
	\item Power down costs are w.l.o.g.\ equal to 0.
	\item $\lambda_0=\lambda_T=0$
	\item All servers are powered down at $t=0$ and $t=T$.
\end{itemize}
We construct a directed acyclic graph as follows:\\
$\forall t\in[T-1],0\le i\le m$ we add vertices $(t,i)$ modelling the number of active servers at time t. Furthermore, we add vertices $(0,0)$ and $(T,0)$ for our initial and final state respectively.\\
In order to warrant that there are at least $\lceil\lambda_t\rceil$ active servers $\forall t\in[T-1]$, we define an auxiliary function which calculates the costs for handling an arrival rate $\lambda$ with $x$ active servers:
\begin{equation}
	c(x,\lambda)\coloneqq\begin{cases}
	  x*f(\lambda/x), & \text{if $\lambda\le x$}\\
	  \infty, & \text{otherwise}
	  \end{cases}
\end{equation}
Then, $\forall t\in[T-2],i,j\in\{0,\ldots,m\}$ we add edges from $(t,i)$ to $(t+1,j)$ with weight
\begin{equation}
	d(i,j,\lambda_{t+1})\coloneqq\underbrace{\beta*\min\{0,j-i\}}_{\text{power up costs}}+c(j,\lambda_{t+1})
\end{equation}
Finally, for $0\le i\le m$ we add edges from $(0,0)$ to $(1,i)$ with weight $d(0,i,\lambda_1)$ and from $(T-1,i)$ to $(T,0)$ with weight $d(i,0,\lambda_T)=0$.
\begin{figure}[H]
\centering
\begin{tikzpicture}[->,>=stealth',auto,node distance=3cm,thick,node/.style={minimum size=1.2cm,circle,draw}]

  \node[node] (1) {0,0};
  \node[node] (4) [below right =of 1] {1,0};
  \node[node] (3) [above =0.5cm of 4] {1,1};
  \node[node] (2) [above right=of 1] {1,n};
  \node[node] (6) [right =of 3] {2,1};
  \node[node] (5) [right =of 2] {2,n};
  \node[node] (7) [right =of 4] {2,0};
  \node[node] (9) [right =of 6] {T-1,1};
  \node[node] (8) [right =of 5] {T-1,n};
  \node[node] (10) [right =of 7] {T-1,0};
  \node[node] (11) [above right =of 10] {T,0};

  \node at ($(5)!.4!(8)$) {\ldots};
  \node at ($(6)!.4!(9)$) {\ldots};
  \node at ($(7)!.4!(10)$) {\ldots};

  \node at ($(2)!.5!(3)$) {\vdots};
  \node at ($(2)!.5!(6)$) {\vdots};
  \node at ($(5)!.5!(6)$) {\vdots};
  \node at ($(8)!.5!(9)$) {\vdots};

  \path[every node/.style={font=\sffamily\small}]
    (1) edge node[left] {$d(0,n,\lambda_1)$} (2)
	edge node[above right=-0.1cm] {$d(0,1,\lambda_1)$} (3)
	edge node[left] {$d(0,0,\lambda_1)$} (4)
    (2) edge node[above] {$d(n,n,\lambda_2)$} (5)
    (3) edge (6)
	edge (7)
    (4) edge (6)
	edge node[below] {$d(0,0,\lambda_2)$} (7)
    (8) edge node[right] {$0$} (11)
    (9) edge node[above] {$0$} (11)
    (10) edge node[above] {$0$} (11);

   \path [->,draw,thick] (1) to ($(1)!.2!(8)$);
   \path [->,draw,thick] (2) to ($(2)!.4!(6)$);
   \path [->,draw,thick] (4) to ($(4)!.4!(5)$);
   \path [->,draw,thick] (3) to ($(3)!.4!(5)$);

   \path [->,draw,thick] ($(3)!.6!(5)$) to (5);
   \path [->,draw,thick] ($(2)!.6!(6)$) to (6);
   \path [->,draw,thick] ($(2)!.6!(7)$) to (7);

   \path [->,draw,thick] ($(6)!.6!(8)$) to (8);
   \path [->,draw,thick] ($(5)!.6!(8)$) to (8);

   \path [->,draw,thick] ($(5)!.6!(9)$) to (9);
   \path [->,draw,thick] ($(6)!.6!(9)$) to (9);
   \path [->,draw,thick] ($(7)!.6!(9)$) to (9);

   \path [->,draw,thick] ($(5)!.6!(10)$) to (10);
   \path [->,draw,thick] ($(6)!.6!(10)$) to (10);
   \path [->,draw,thick] ($(7)!.6!(10)$) to (10);

   \path[every node/.style={font=\sffamily\small}] [->,draw,thick] ($(2)!.8!(11)$) -- node[above] {0} ++ (11);

\end{tikzpicture}
\caption{All edges from $(t,i)$ to $(t+1,j)$ have weight $d(i,j,\lambda_{t+1})$}
\end{figure}

\begin{algorithm}[H]
    \caption{Calculate costs for $n$ homogeneous servers}
    \begin{algorithmic}[1]
        \Require{Convex cost function $f$, $\lambda_0=\lambda_T=0$, $\forall t\in[T-1]:\lambda_t\in[0,n]$}
   \Function{schedule}{$n,T,\beta,\lambda_1,\ldots,\lambda_{T-1}$}
	\If{$T<2$}
		\State \Return $(0,0)$
	\EndIf
	\Blet{$p[2\ldots T-1,2]$ and $m[1\ldots T-1,n]$}{new arrays}
	\For{$j \gets 0 \textrm{ to } n$}
		\Let{$m[1,j]$}{$d(0,j,\lambda_1)$}
	\EndFor
	\For{$t \gets 1 \textrm{ to } T-2$}
		\For{$j \gets 0 \textrm{ to } n$}
			\Let{$opt$}{$\infty$}
			\For{$i \gets 0 \textrm{ to } n$}
				\Let{$m[t+1,j]$}{$m[t,i]+d(i,j,\lambda_{t+1})$}
				\If{$m[t+1,j]<opt$}
					\Let{$opt$}{$m[t+1,j]$}
					\Let{$p[t+1,j]$}{$i$}
				\EndIf
			\EndFor
		\EndFor
	\EndFor
	\State \Return{$p$ and $m$}
  \EndFunction
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
    \caption{Extract schedule for n homogeneous servers}
    \begin{algorithmic}[1]
   \Function{Extract}{$n,p,m,T$}
	\Blet{$x[0\ldots T]$}{a new array}
	\Let{$x[0]$}{$x[T]\leftarrow 0$}
	\Let{$x[T-1]$}{$\underset{0\le i\le n}{arg\ min}\{m[T-1,i]\}$}
	\For{$t \gets T-2 \textrm{ to } 1$}
		\Let{$x[t]$}{$p[t+1,x[t+1]]$}
	\EndFor
	\State \Return{$x$}
  \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Runtime analysis}
Schedule: Loop 5,8 and 10 run $n+1$ times, loop 7 runs $T-2$ times\\
Extract: Loop 5 runs $T-2$ times, argmin 4 takes time $n+1$.\\
For $T,n\rightarrow\infty$ it holds:
\begin{equation}
	\mathcal{O}(n+1+(T-2)*(n+1)^2+T-2+n+1)=\mathcal{O}(2*n+T+(T-2)*(n+1)^2)=\mathcal{O}(T*n^2) 
\end{equation}

\subsection{Proof of correctness}
First, we show that for $x$ active servers and an arrival rate $\lambda$, the best method is to assign each server a load of $\lambda/x$:\\
$\forall x\in\mathbb{N},\mu_i\in[0,1]:\sum\limits_{i=1}^{x}{\mu_i}=1:$
\begin{alignat}{5}
	f\Bigl(\frac{\lambda}{x}\Bigr)=&&f\Bigl(\sum\limits_{i=1}^x{\frac{\mu_i*\lambda}{x}}\Bigr)&\stackrel{\text{Jensen's inequality}}{\le}&&\sum\limits_{i=1}^x\frac{1}{x}f(\mu_i*\lambda) \nonumber\\
	\Leftrightarrow &&x*f\Bigl(\frac{\lambda}{x}\Bigr)&\qquad\quad\le&&\sum\limits_{i=1}^xf(\mu_i*\lambda)
\end{alignat}

%\begin{proof}[Sketch for proof of correctness]
%We show that the algorithm calculates the correct costs and returns an optimal schedule $\forall T\in\mathbb{N}_{\ge 2}$ using induction.
%\begin{enumerate}
%\item[\textbf{Basis:}] For $T=2$ it holds $\lambda_0=\lambda_2=x_0=x_T=0$ and $\lambda_1\in(0,2]$. Therefore, the costs for the optimal schedule are $min\bigl\{f(\lambda_1)+\beta, f(\lambda_1/2)+2*\beta\bigr\}$. These costs are calculated at line 4-5 and minimized at line 18.\end{enumerate}
%\item[\textbf{Inductive step:}] Assuming the algorithm delivers a correct result for $T\in\mathbb{N}_{\ge 2}$, we show that it delivers a correct result for $T+1$.\\
%Firstly, we recognize that the executed statements of the algorithm for $T$ and $T+1$ are the same up to the last iteration of the for-loop at line 6. Hence, using the induction hypothesis, we can assume that $m_{1,\{1,2\}}$ up to $m_{T-1,\{1,2\}}$ are calculated correctly at this point.\\
%In order to calculate the minimum costs for using 1 machine at time T, we simply need to find $min\bigl\{m_{T-1,1},m_{T-1,2}\bigr\}+f(\lambda_T)$. This step is handled at line 7-8.\\
%In order to calculate the minimum costs for using 2 machines at time T, we need to find $min\bigl\{m_{T-1,1}+\beta,m_{T-1,2}\bigr\}+f(\lambda_T/2)$. This step is handled at line 9-16.\\
%Note: We do not need to consider possibilities where 2 servers are active but only 1 server is used. This follows from the convexity of $f$:
    %\begin{alignat*}{5}
        %f\Bigl(\frac{0+\lambda_t}{2}\Bigr)&=&f\Bigl(\frac{\lambda_t}{2}\Bigr)&\stackrel{convexity}{\le}\frac{f(0)+f(\lambda_t)}{2}\\
        %&\Leftrightarrow\quad&\underbrace{2*f\Bigl(\frac{\lambda_t}{2}\Bigr)}_{\text{using 2 servers}}&\quad\le\underbrace{f(0)+f(\lambda_t)}_{\text{2 active servers, using only 1}}
    %\end{alignat*}
%\end{proof}
\end{sloppypar}
\end{document}
